/*
 * DateAD.java
 */
package p3; //Jens
import java.util.*;

/**
 * <h1>DateAD</h1><br />
 * 
 * <b>Description</b><br />
 * DateAD class which holds all the values for the associated DateAD object.
 * <br />
 * There are four ways to construct a DateAD object: <br />
 * <ol>
 * <li>No params results in the current date</li>
 * <li>One param as a short sets the current date with the input param as the
 * day of the month; if day is invalid then it is the current date.</li>
 * <li>Two params as shorts sets the day then the month with the year being
 * the current year. If any param is invalid then the date is the current 
 * date</li>
 * <li>Three params as shorts sets the date to the input as day, month, year.
 * If any param is invalid then the date is the current date</li>
 * </ol>
 * <br />
 * <i><b>Note</b></i><br />
 * You can also construct a DateAD object by calling passing having the 3rd
 * parameter be a boolean "true".  This takes in the day of the year 
 * and the year and returns a date if input is valid.
 * It sets the date to the current date otherwise.
 * 
 * @author Jens Bodal
 * @version 1.0
 * 
 * Compiler Java 1.7 OS: Windows 7, OSX Hardware: PC
 * 
 * November 11, 2013 JB Completed v1.0
 */
public class DateAD {
    //CONSTANTS
    /**
     * The minimum year for the Gregorian calendar is 1752
     */
    public static final short MIN_YEAR = 1752;
    /**
     * There are 12 months in a year
     */
    public static final short MONTHS_YEAR = 12;
    /**
     * There are 7 days in a week
     */
    public static final short DAYS_WEEK = 7;
    
    //TO MOVE TO BOTTOM
    private short month;
    private short year;
    private short dayOfMonth;
    private short dayOfYear; 
    private short dayOfWeek_Number; //0 = Sunday
    private String dayOfWeek_Literal; //Sunday, Monday, etc.
    private String month_Literal; //January, February, etc.
    private short daysInYear = 365;
    private boolean isLeapYear;
    
    
    /**
     * This is a likely poorly implemented method which I can't see being
     * used anywhere other than for the scope of this project
     * @param inputDate DateAD object for input
     * @return returns String for whether date is in the past, future, or today
     */
    public String compare(DateAD inputDate) {
        if (this.equals(inputDate)) {
            return "today";
        }
        else if (this.lessThan(inputDate)) {
            return "in the past";
        }
        else {
            return "in the future";
        }
    }

    /**
     *
     * @param inputDate DateAD object for input
     * @return true if inputDate DateAD object is less than DateAD object
     */
    public boolean lessThan(DateAD inputDate) {
        if (this.year == inputDate.year &&
                this.dayOfYear < inputDate.dayOfYear) {
            return true;
        }
        else if (this.year < inputDate.year) {
            return true;
        }
        else {
            return false;
        }
    } 

    /**
     * Compares DateAD object to given DateAD object and returns true if both
     * are the same date
     * @param inputDate DateAD object for input
     * @return true if both dates refer to the exact same date
     */
    public boolean equals(DateAD inputDate) {
        if (this.year == inputDate.year && 
                this.dayOfYear == inputDate.dayOfYear) {
            return true;
        }
        else {
            return false;
        }
    } 
    
    
    /**
     * Please ignore this code for the scope of this project.  I wanted to 
     * implement JUnit tests and was reading up on Hashcodes and overriding
     * the equals method.  I did not fully test if my Override works completely
     * @param other Input object for comparison
     * @return true if both objects are equal to each other 
     */
    @Override
    public boolean equals(Object other) {
        System.out.println(getClass());
        if (other == null) return false;
        if (other == this) return true;
        if (getClass() != other.getClass()) {
            return false;
        }
        else {return equals((DateAD)other);}
    } 

    /**
     * This was generated by netbeans, I am planning on reading up on this 
     * later
     * @return has code
     */
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 89 * hash + this.year;
        hash = 89 * hash + this.dayOfYear;
        return hash;
    }
    
    /**
     * Default constructor which returns the current date if no input is given
     */
    public DateAD() {
        setCurrentDate();
    }
    
    /**
     * Constructor which takes in the day of the month and returns a DateAD
     * object; if any input is invalid this will return the current date.
     * @param dayOfMonth short number representing day of month
     */
    public DateAD(short dayOfMonth) {
        setCurrentDate();
        setDayOfMonth(dayOfMonth);
    }
    
    /**
     * Constructor which takes in the day of the month and the month number and
     * returns a DateAD object; if any input is invalid this will return
     * the current date.
     * @param dayOfMonth short number representing day of month
     * @param month short number representing the month (1 = January)
     */
    public DateAD(short dayOfMonth, short month) {
        setCurrentDate();
        setMonth(month);
        setDayOfMonth(dayOfMonth);
    }

    /**
     * Constructor which takes in the day of the month, the month number and 
     * the year and returns a DateAD object; if any input is invalid this 
     * will return the current date.
     * @param dayOfMonth short number representing day of month
     * @param month short number representing the month (1 = January)
     * @param year short number representing the 4-digit year
     */
    public DateAD(short dayOfMonth, short month, short year) {
        setCurrentDate();
        if (year > MIN_YEAR) {
            setYear(year);
            setMonth(month);
            setDayOfMonth(dayOfMonth);            
        }
    }
    
    /**
     * Constructor to return a DateAD object from a given day of the year and
     * year.
     * @param dayOfYear short number for day in year
     * @param year short number for year
     * @param isDateFromYear must be true to use this constructor
     */
    public DateAD(short dayOfYear, short year, boolean isDateFromYear){
        setCurrentDate();
        if (isDateFromYear && year > MIN_YEAR) {
            if (isLeapYear(year)) {
                MONTHNAMES.FEBRUARY.month_NumberOfDays = 29;
            }
            else {
                MONTHNAMES.FEBRUARY.month_NumberOfDays = 28;
            }
            short newMonth = 0;

            if (dayOfYear == 366 && isLeapYear(year)) {
                if (isLeapYear(year)) {
                    dayOfYear = 31;
                    newMonth = 12;
                }
            }
            if (year < MIN_YEAR) {
                year = this.year;
                newMonth = this.month;
                dayOfYear = this.dayOfMonth;
            }
            else {
                for (MONTHNAMES M : MONTHNAMES.values()) {
                    if (dayOfYear - M.month_NumberOfDays <= 0) {
                        newMonth = (short)(M.month_Number + 1);
                        break;
                    }
                    else {
                        dayOfYear -= M.month_NumberOfDays;
                    }
                }
            }
            setYear(year);
            setMonth(newMonth);
            setDayOfMonth(dayOfYear);
        }
    }

    /**
     * Returns the date after the input DateAD object
     * @param inputDate DateAD object as input
     * @return DateAD object that is one day ahead of input DateAD object
     */
    public DateAD getTomorrow(DateAD inputDate) {
        short inputDayOfYear = inputDate.dayOfYear;
        short inputYear = inputDate.year;
        
        if (inputDayOfYear == 365 || inputDayOfYear == 366) {
            inputYear += 1;
            inputDayOfYear = 1;
        }
        else {
            inputDayOfYear += 1;
        }

        return new DateAD(inputDayOfYear, inputYear, true);
    }
    
    /**
     * Returns the date prior to the input DateAD object
     * @param inputDate DateAD object as input
     * @return DateAD object that is one day before of input DateAD object
     */
    public DateAD getYesterday(DateAD inputDate) {
        short inputDayOfYear = inputDate.dayOfYear;
        short inputYear = inputDate.year;
        
        if (inputDayOfYear == 1) {
            inputYear -= 1;
            if (!isLeapYear(inputYear)) {
                inputDayOfYear = 365;
            }
            else {
                inputDayOfYear = 366;
            }
        }
        else {
            inputDayOfYear -= 1;
        }
        
        return new DateAD(inputDayOfYear, inputYear, true);
    }
    
    /**
     * returns the day of the month as a short
     * @return the day of the month as a short
     */
    public short getDayOfMonth(){
        return dayOfMonth;
    }
    
    /**
     * returns the month as a short (January = 1)
     * @return the month as a short (January = 1)
     */
    public short getMonth(){
        return month;
    }
    
    /**
     * returns the year as a short
     * @return the year as a short
     */
    public short getYear(){
        return year;
    }
    
    /**
     *
     * @return the day of the week in text (0 = Sunday)
     */
    public String getDayOfWeek() {
        return dayOfWeek_Literal;
    }
    
    /**
     *
     * @return the day of the year (1-365 || 1-366 if leap year)
     */
    public short getDayOfYear() {
        return dayOfYear;
    }
    
    private void setDayOfMonth(short dayOfMonth) {
        isLeapYear = isLeapYear(this.year);
        if (isLeapYear) {
            MONTHNAMES.FEBRUARY.month_NumberOfDays = 29;
            this.daysInYear += 1;
        }
        
        if (dayOfMonth > 0 && dayOfMonth <= daysInMonth(month)) {
            this.dayOfMonth = dayOfMonth;
        }
        else {
            setCurrentDate();
        }
        
        setDayOfYear(this.dayOfMonth, month);
        setDayOfWeek(this.dayOfMonth, month, year);
    }

    private void setMonth(short month) {
        if (month > 0 && month <= MONTHS_YEAR) {
            this.month = month;
        }
        else {
            setCurrentDate();
        }
    }
    
    private void setYear(short year){
        if (year < MIN_YEAR) {
            year = this.year;
        }
        this.year = year;
    }

    private short daysInMonth(short month) {
        for (MONTHNAMES M : MONTHNAMES.values()) {
            if (month - 1 == M.month_Number) {
                month_Literal = M.month_Literal;
                return M.month_NumberOfDays;
            }
        }
        return daysInMonth(this.month);
    }
    
    private void setDayOfYear(short dayOfMonth, short month) {
     short dayCount = 0;
     for (MONTHNAMES M : MONTHNAMES.values()) {
          if (month - 1 > M.month_Number) {dayCount+= M.month_NumberOfDays;}
     }
     dayCount += dayOfMonth;
     dayOfYear = dayCount;
}

    
    /**
     * Based on the following formula:<br/>
     * Zeller's Congruence: en.wikipedia.org/wiki/Zeller's_congruence<br />
     * h = (d + [13(m+1)/5] + y + [y/4] + [c/4] + 5c + 1) mod 7<br />
     * <ul>
     * <li>Brackets denote the value without the remainder, i.e. FLOOR</li>
     * <li>h is day of week, 0 = Saturday</li>
     * <li>d is day of month</li>
     * <li>m is month number, January is 13 and February is 14</li>
     * <li><b>If the month number is January (13) or February (14) then
     * the year = year - 1</b></li>
     * <li>y is year of century, e.g. for 2013 d = 13, 2000 = 99</li>
     * <li>c is century, e.g. for 2013 c = 20, 2000 = 19</li><br />
     * </ul>
     * 
     * @return the day of the week in String format
     */
    private String setDayOfWeek(
            short dayOfMonth, short month, short year) {
        
        short monthValue;
       
        //Calculate monthValue
        switch (month) {
            case 1:     monthValue = 13;
                        break;
            case 2:     monthValue = 14;
                        break;
            default:    monthValue = month;
        }
        
        if (monthValue == 13 || monthValue == 14) {year -= 1;}
        short twoDigitYear = (short)(year % 100);
        short century = (short)(year / 100);
        // d
        short dayCalc = dayOfMonth;
        // [13(m+1)/5]
        short monthCalc = (short)(13 * (monthValue+1) / 5);
        // y + [y/4]
        short twoDigitYearCalc = (short)(twoDigitYear + (twoDigitYear / 4));
        // [c/4] + 5c
        short centuryCalc = (short)((century / 4) + (century * 5));
        // h
        short numericalDayOfWeek = (short)
              ((dayCalc + monthCalc + twoDigitYearCalc + centuryCalc - 1) % 7);

        switch (numericalDayOfWeek) {
            case 0:
                dayOfWeek_Literal = DAYNAMES.SUNDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.SUNDAY.dayOfWeek_Number;
                break;
            case 1:
                dayOfWeek_Literal = DAYNAMES.MONDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.MONDAY.dayOfWeek_Number;
                break;
            case 2:
                dayOfWeek_Literal = DAYNAMES.TUESDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.TUESDAY.dayOfWeek_Number;
                break;
            case 3:
                dayOfWeek_Literal = DAYNAMES.WEDNESDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.WEDNESDAY.dayOfWeek_Number;
                break;
            case 4:
                dayOfWeek_Literal = DAYNAMES.THURSDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.THURSDAY.dayOfWeek_Number;
                break;
            case 5:
                dayOfWeek_Literal = DAYNAMES.FRIDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.FRIDAY.dayOfWeek_Number;
                break;
            case 6:
                dayOfWeek_Literal = DAYNAMES.SATURDAY.dayOfWeek_Literal;
                dayOfWeek_Number = DAYNAMES.SATURDAY.dayOfWeek_Number;
                break;
        }
        return dayOfWeek_Literal;
    }
    
    
    /**
     * isLeapYear takes input as a short and determines if it is 
     * a leap year. <br /> <br />
     * <i>A year is a leap year if it is divisible by 4 unless it divisible by 
     * 100 except if it is also divisible by 400.</i>
     * @param inputYear the year as a short
     * @return boolean: {@code true} if leap year, {@code false} if otherwise
     */
    public static boolean isLeapYear(short inputYear) {
        if (inputYear % 4 == 0) {
            if (inputYear % 100 == 0) {
                if (inputYear % 400 == 0) {
                    return true; //Divisible by 4, 100, and 400
                }
                else {
                    return false; //Divisible by 4, 100, but not 400
                }
            }
            else {
                return true; //Divisible by 4 but not 100
            }
        }
        else {
            return false; //Not divisible by 4
        }
    }
    
    /**
     * Code provided by project guidelines.  Sets the year, month, and 
     * day of month to the current date
     */
    public final void setCurrentDate() {
        GregorianCalendar cal = new GregorianCalendar();
        setYear((short)cal.get(GregorianCalendar.YEAR));
        setMonth(((short)(cal.get(GregorianCalendar.MONTH)+1)));
        setDayOfMonth((short)cal.get(GregorianCalendar.DAY_OF_MONTH));
    }
    
    private static enum MONTHNAMES {
        //month_Number, month_Literal, month_NumberofDays
        JANUARY ((short)0, "January", (short)31),
        FEBRUARY ((short)1, "February", (short)28),
        MARCH ((short)2, "March", (short)31),
        APRIL ((short)3, "April", (short)30),
        MAY ((short)4, "May", (short)31),
        JUNE ((short)5, "June", (short)30),
        JULY ((short)6, "July", (short)31),
        AUGUST ((short)7, "August", (short)31),
        SEPTEMBER ((short)8, "September", (short)30),
        OCTOBER ((short)9, "October", (short)31),
        NOVEMBER ((short)10, "November", (short)30),
        DECEMBER ((short)11, "December", (short)31);
        
        private short month_Number;
        private String month_Literal;
        private short month_NumberOfDays; 
        
        MONTHNAMES(
                short month_Number, 
                String month_Literal, 
                short month_NumberOfDays) {
            this.month_Literal = month_Literal;
            this.month_Number = month_Number;
            this.month_NumberOfDays = month_NumberOfDays;
        } //End MONTHNAMES constructor
    } //End MONTHNAMES enum
    
    private static enum DAYNAMES {
        SUNDAY ("Sunday", (short)0),
        MONDAY ("Monday", (short)1),
        TUESDAY ("Tuesday", (short)2),
        WEDNESDAY ("Wednesday", (short)3),
        THURSDAY ("Thursday", (short)4),
        FRIDAY ("Friday", (short)5),
        SATURDAY ("Saturday", (short)6);

        private String dayOfWeek_Literal;
        private short dayOfWeek_Number;
        
        DAYNAMES(String dayOfWeek_Literal, short dayOfWeek_Number) {
            this.dayOfWeek_Literal = dayOfWeek_Literal;
            this.dayOfWeek_Number = dayOfWeek_Number;
        }
    }

    /**
    @return the day-of-week, day-of-month, month, year (as text)
    * e.g., "Tuesday, 2 January, 2007"
    */
    @Override
    public String toString() {
        return String.format("%s, %d %s, %d", 
                dayOfWeek_Literal,
                dayOfMonth,
                month_Literal,
                year);
    }    
} //End DateAD class
